<application>
  <component name="AppStorage">
    <histories>
      <item value="launcher" />
      <item value="reentrant" />
      <item value="contracts" />
      <item value="either" />
      <item value="conform to either" />
      <item value="conform" />
      <item value="but must have signatures that conform to either * {@linkplain Provider provision} or {@linkplain MembersInjector members-injection} contracts." />
      <item value="In order to get the proper behavior associated with a scope annotation, it is the caller's * responsibility to instantiate new component instances when appropriate. A {@link Singleton} * component, for instance, should only be instantiated once per application, while a {@code * RequestScoped} component should be instantiated once per request. Because components are * self-contained implementations, exiting a scope is as simple as dropping all references to the * component instance." />
      <item value="Each Dagger component can be associated with a scope by annotating it with the {@linkplain * Scope scope annotation}. The component implementation ensures that there is only one provision of * each scoped binding per instance of the component. If the component declares a scope, it may only * contain unscoped bindings or bindings of that scope anywhere in the graph. For example:" />
      <item value="In the case that a component has no component dependencies and only no-arg modules, the * generated component will also have a factory method {@code create()}. {@code * SomeComponent.create()} and {@code SomeComponent.builder().build()} are both valid and * equivalent." />
      <item value="While a members-injection method for a type will accept instances of its subtypes," />
      <item value="A note about covariance" />
      <item value="Calling {@link MembersInjector#injectMembers} on the returned object will * perform the same work as a members injection method." />
      <item value="Members-injection methods have a single parameter and inject dependencies into each of the * {@link Inject}-annotated fields and methods of the passed instance. A members-injection method * may be void or return its single parameter as a convenience for chaining. The following are all * valid members-injection method declarations:" />
      <item value="The following provision methods all request provision of the same type, but each * implies different semantics:" />
      <item value="but will defer it until the first call to {@link * Lazy#get}." />
      <item value="will only ever request a single" />
      <item value="A {@link * Lazy} will only ever request a single provision," />
      <item value="A {@link Provider} allows the user of * the component to request provision any number of times by calling {@link Provider#get}." />
      <item value="more explicitly control provision requests" />
      <item value="Provision methods, like typical {@link Inject injection} sites" />
      <item value="The following are * all valid provision method declarations:" />
      <item value="Each method may have a {@link Qualifier} annotation as well" />
      <item value="Provision" />
      <item value="Provision methods have no parameters" />
      <item value="Every type annotated with @Component must contain at least one abstract component method. Component methods may have any name, but must have signatures that conform to either provision or members-injection contracts." />
      <item value="Injects dependencies into the fields and methods on instances of type T. Ignores the presence or absence of an injectable constructor." />
      <item value="Injects dependencies into the fields and methods of instance. Ignores the presence or absence of an injectable constructor. Whenever a Component creates an instance, it performs this injection automatically (after first performing constructor injection), so if you're able to let the component create all your objects for you, you'll never need to use this method." />
      <item value="Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or * absence of an injectable constructor." />
      <item value="Ordering of * injection among fields and among methods in the same class is not specified." />
      <item value="Fields and methods * in superclasses are injected before those in subclasses." />
      <item value="Constructors are * injected first, followed by fields, and then methods." />
      <item value="An injectable member may have any access * modifier (private, package-private, protected, public)." />
      <item value="as well as" />
      <item value="May apply to static * as well as instance members." />
      <item value="Identifies injectable constructors, methods, and fields." />
      <item value="fields" />
      <item value="Annotates an interface or abstract class for which a fully-formed, dependency-injected implementation is to be generated from a set of modules(). The generated class will have the name of the type annotated with @Component prepended with Dagger. For example, @Component interface MyComponent {...} will produce an implementation named DaggerMyComponent." />
      <item value="Annotates an interface or abstract class for which a fully-formed," />
      <item value="formed" />
      <item value="fully-formed" />
      <item value="Annotates an interface or abstract class for which a fully-formed" />
      <item value="Identifies qualifier annotations. Anyone can define a new qualifier. A * qualifier annotation:" />
      <item value="exercise" />
      <item value="guaranteed" />
      <item value="Typically implemented by an injector. For * any type {@code T} that can be injected, you can also inject * {@code Provider&lt;T&gt;}. Compared to injecting {@code T} directly, injecting * {@code Provider&lt;T&gt;} enables:" />
      <item value="Provider" />
      <item value="Members" />
      <item value="example" />
      <item value="Future" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="67" />
        <entry key="ENGLISH" value="67" />
        <entry key="ROMANIAN" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>